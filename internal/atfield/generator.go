package atfield

import (
	"fmt"
	"go/format"
	"io/ioutil"
	"path/filepath"
	"strings"
)

const (
	fileHead   = "// Code generated by atfield. DO NOT EDIT.\n\n//+build !atfield\n\n"
	bulkPatter = `func Bulk%s(source []*%s.%s) []*%s.%s {
		result := make([]*%s.%s, 0, len(source))
		for _, v := range source {
			result = append(result, %s(v))
		}
		return result
	}

`
)

// generate convert files
func (e *engine) generateConverts() {
	e.generate(fileHead)
	e.definePackage()
	e.importPackages()
	for _, v := range e.linkStructs {
		e.generateConvertFunction(v[0], v[1])
		e.generateBulkConvertFunction(v[0], v[1])
		e.generateConvertFunction(v[1], v[0])
		e.generateBulkConvertFunction(v[1], v[0])
	}
	data, err := format.Source(e.buf.Bytes())
	if err != nil {
		e.err = err
		return
	}
	e.err = ioutil.WriteFile(filepath.Join(e.outfileDir, "atfield.go"), data, 0644)
}

// generate syntaxes of define file package
func (e *engine) definePackage() {
	e.generate("package %s\n\n", e.pkg.Name)
}

// write import syntaxes
func (e *engine) importPackages() {
	e.generate("import (\n")
	for _, v := range e.linkPackages {
		e.generateImportPackage(v)
	}
	e.generate(")\n\n")
}

// basic generate method
func (e *engine) generate(syntax string, args ...interface{}) {
	e.errorIntercept(func() {
		_, e.err = fmt.Fprintf(e.buf, syntax, args...)
	})
}

// generate syntaxes of import packages
func (e *engine) generateImportPackage(p *pkg) {
	s := strings.Split(p.Dir, "/")
	if p.Alias != s[len(s)-1] {
		e.generate("\t%s \"%s\"\n", p.Alias, p.Dir)
	} else {
		e.generate("\t\"%s\"\n", p.Dir)
	}
}

// generate one convert function
func (e *engine) generateConvertFunction(x, y structId) {
	e.generate("func %s(source *%s.%s) *%s.%s {\n",
		functionName(x, y),
		x.PkgName, x.StructName,
		y.PkgName, y.StructName,
	)
	e.generate("\tresult := &%s.%s{}\n", y.PkgName, y.StructName)
	e.generateFieldConvert(x, y)
	e.generate("\treturn result\n")
	e.generate("}\n\n")
}

// generate bulk convert function
func (e *engine) generateBulkConvertFunction(x, y structId) {
	funcName := functionName(x, y)
	e.generate(
		bulkPatter,
		funcName,
		x.PkgName,
		x.StructName,
		y.PkgName,
		y.StructName,
		y.PkgName,
		y.StructName,
		funcName,
	)
}

// generate name of convert function
func functionName(x, y structId) string {
	var sb strings.Builder
	sb.WriteString(strings.ToUpper(x.PkgName))
	sb.WriteString(x.StructName)
	sb.WriteString("To")
	sb.WriteString(strings.ToUpper(y.PkgName))
	sb.WriteString(y.StructName)
	return sb.String()
}

// generat fields convert syntaxes
func (e *engine) generateFieldConvert(x, y structId) {
	structX, structY := e.structSet[x], e.structSet[y]
	for nameX, typeX := range structX {
		if ifPublicField(nameX) {
			if typeY, ok := structY[nameX]; ok {
				// if field can be founc in struct y
				e.fieldConvert(&fieldParam{Name: nameX, Type: typeX}, &fieldParam{Name: nameX, Type: typeY})
			} else {
				// if field can't be founc in struct y
				fDir := fieldDir{StructId: x, FieldName: nameX}
				if beLinked, ok := e.linkFieldSet[fDir]; ok {
					if nameY, ok := beLinked[y]; ok {
						if typeY, ok := structY[nameY]; ok {
							e.fieldConvert(&fieldParam{Name: nameX, Type: typeX}, &fieldParam{Name: nameY, Type: typeY})
						}
					}
				}
			}
		}
	}
}

// generat one field convert syntaxes
func (e *engine) fieldConvert(x, y *fieldParam) {
	if x.Type == y.Type {
		e.generate("\tresult.%s = source.%s\n", y.Name, x.Name)
	} else if ifTypeConvertible(y.Type, x.Type) {
		e.generate("\tresult.%s = %s(source.%s)\n", y.Name, y.Type, x.Name)
	}
}
